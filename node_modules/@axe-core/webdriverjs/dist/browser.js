"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.axeRunLegacy = exports.axeGetFrameContext = exports.axeFinishRun = exports.axeRunPartial = exports.axeSourceInject = void 0;
// https://github.com/vercel/pkg/issues/676
// we need to pass a string vs a function so we manually stringified the function
// There are no try/catch blocks needed in these scripts. If an error occurs
// Selenium pass them onto the catch block.
function axeSourceInject(driver, axeSource, config) {
    return promisify(driver.executeScript("\n      " + axeSource + ";\n      window.axe.configure({\n        branding: { application: 'webdriverjs' }\n      });\n      var config = " + JSON.stringify(config) + ";\n      if (config) {\n        window.axe.configure(config);\n      }\n      var runPartial = typeof window.axe.runPartial === 'function';\n      return { runPartialSupported: runPartial };\n    "));
}
exports.axeSourceInject = axeSourceInject;
function axeRunPartial(driver, context, options) {
    return promisify(driver.executeAsyncScript("\n      var callback = arguments[arguments.length - 1];\n      var context = " + JSON.stringify(context) + " || document;\n      var options = " + JSON.stringify(options) + " || {};\n      window.axe.runPartial(context, options).then(res => JSON.stringify(res)).then(callback);\n    "));
}
exports.axeRunPartial = axeRunPartial;
function axeFinishRun(driver, axeSource, config, partialResults, options) {
    // Inject source and configuration a second time with a mock "this" context,
    // to make it impossible to sniff the global window.axe for results.
    return promisify(driver
        .executeAsyncScript("\n      var callback = arguments[arguments.length - 1];\n\n      " + axeSource + ";\n      window.axe.configure({\n        branding: { application: 'webdriverjs' }\n      });\n      var config = " + JSON.stringify(config) + ";\n      if (config) {\n        window.axe.configure(config);\n      }\n\n      var partialResults = " + JSON.stringify(partialResults) + ";\n      partialResults = partialResults.map(res => JSON.parse(res));\n      var options = " + JSON.stringify(options || {}) + ";\n      window.axe.finishRun(partialResults, options).then(res => JSON.stringify(res)).then(callback);\n    ")
        .then(function (res) { return JSON.parse(res); }));
}
exports.axeFinishRun = axeFinishRun;
function axeGetFrameContext(driver, context) {
    return promisify(driver.executeScript("\n      var context = " + JSON.stringify(context) + "\n      var frameContexts = window.axe.utils.getFrameContexts(context);\n      return frameContexts.map(function (frameContext) {\n        return Object.assign(frameContext, {\n          href: window.location.href, // For debugging\n          frame: axe.utils.shadowSelect(frameContext.frameSelector)\n        });\n      });\n    "));
}
exports.axeGetFrameContext = axeGetFrameContext;
function axeRunLegacy(driver, context, options, config) {
    // https://github.com/vercel/pkg/issues/676
    // we need to pass a string vs a function so we manually stringified the function
    return promisify(driver
        .executeAsyncScript("\n      var callback = arguments[arguments.length - 1];\n      var context = " + JSON.stringify(context) + " || document;\n      var options = " + JSON.stringify(options) + " || {};\n      var config = " + JSON.stringify(config) + " || null;\n      if (config) {\n        window.axe.configure(config);\n      }\n      window.axe.run(context, options).then(res => JSON.stringify(res)).then(callback);\n    ")
        .then(function (res) { return JSON.parse(res); }));
}
exports.axeRunLegacy = axeRunLegacy;
/**
 * Selenium-webdriver thenable aren't chainable. This fixes it.
 */
function promisify(thenable) {
    return new Promise(function (resolve, reject) {
        thenable.then(resolve, reject);
    });
}
//# sourceMappingURL=browser.js.map